package BST;
/*
 * Alisha Mimdani
 * CSC2720 - 86474
 * Instructor Bhola
 */
import java.util.Arrays;
import java.util.Date;
//package today;
import java.util.Random;
import java.util.Scanner;

import javax.swing.JOptionPane;

/**
 * The purpose of this class is to develop a solution that will sort a randomly
 * generated array and take this unsorted list and sort it. The array's data
 * type is of type integer. In this array there are a total of 100 integers
 * ranging from 0 to 99. These integers are randomly generated by implementing
 * the random() class provided in the java library. Another purpose of this
 * program is to gain experience with Binary Search Trees and building a
 * LinkedList. The data structure used to store the numbers is an array and the
 * array is sorted using an infix recursive method
 * 
 * @author Alisha Mimdani
 *
 */
public class BSTree {
	/*
	 * My java field
	 */
	public node firstNode; // declaring my node

	public int sizeD; // Declaring my variable that im using to control the size
	

	/**
	 * This is the default constructor. In the default constructor the node and
	 * sizeD variable are initialized. An empty list is constructed and takes in
	 * no parameters
	 */
	BSTree() {
		firstNode = null;
		sizeD = 0;
	}

	/**
	 * The method isEmpty() serves to check whether a node has a value of null
	 * or not. If the list contains no elements within it it will return true
	 * and if this collection does contain elements it will return false. To
	 * implement this method you must have an object of BSTree.
	 * 
	 * @return boolean
	 */
	public boolean isEmpty() {
		boolean check; // declaring my boolean variable
		if (firstNode == null) {
			check = true; // set to true if it is empty
		} else {
			check = false; //set to false if it contains elements

		}
		return check;
	}
	/**
	 * This methods purpose is to insert the numbers given to the object created. This object's
	 * type is of BSTree. The parameters are the randomly generated numbers created implementing the
	 * random() class and loc is for keeping a tab for location of each element. Within this method
	 * an object of the node class is created and the parameters are passed to it. The parameters are then
	 * stored in the fields created in the node class called rangeNum and positiond
	 * @param number
	 * @param loc
	 */
	public void insertFirstNodee(int number, int loc) {
		node newNode = new node(number, loc); //implementing the node class
		newNode.next = firstNode;
		firstNode = newNode; 

	}
	/**
	 * The purpose of this method is to count the number of elements within this collection
	 * recursively. The method takes in the parameter of a node. The base case is if the node is null
	 * then it will return the value of 0. If it is not null then it will add 1 until the node reaches a value of null
	 * @param rNodes
	 * @return int
	 */
	public int getCountR(node rNodes) {
		if (rNodes != null) {
			return 1 + getCountR(rNodes.next);
		} else {
			return 0;
		}
	}
 
	/**
	 * The purpose of this method is to sort the list of integers recursively. This method 
	 * accepts to variable. One of type int and one that is a node. The algorithm used in this method
	 * is that if we encounter a null value the last node in the list is the last number remaining from the 
	 * list of random integers created. Other than that the values of each integer from the list is compared with the previous node
	 * If the value of the node is greater than or equal to the previous it is placed toward the back of the list if it is less then it is
	 * placed towards the front of the list. 
	 * @param m
	 * @param mk
	 * @return mk
	 */
	public node placeNum(int m, node mk) {

		if (mk == null) {

			mk = new node(m, mk);
			return new node(m, mk);
		} else if (mk.rangeNum >= m) {

			mk.rightN = placeNum(m, mk.rightN); 
		} else if (mk.rangeNum <= m) {

			mk.leftN = placeNum(m, mk.leftN);
		}

		return mk;
	}
	/**
	 * This is the main method. Without the main method we have no driver program. In this main method i created
	 * an object of my UDT in order to execute the method responsible for displaying the unsorted and sorted 
	 * collection of elements.
	 * @param args
	 */
	public static void main(String[] args) {

		BSTree n = new BSTree();
		n.run();// calling my run method

	}
	/**
	 * In the run method i display my name, course, crn and program name. Within this method is where
	 * I declare my array that holds all of the integers. In this method i also initialize my object
	 * of BSTree by calling the insertFirstNodee method. In order to create an array of random numbers
	 * i used a while loop to execute until i filled up the array.
	 */
	public void run() {
		Date today = new Date();
		JOptionPane.showMessageDialog(null, "Alisha Mimdani\nCSC270 - 86474\nInstructor:Bhola\nProgram:BSTree\nTodays Date:" + today +"\nDue Date:11/29/2017");
		Scanner in = new Scanner(System.in);
		BSTree op = new BSTree();
		System.out.println("The tree is empty ? \n That is " + op.isEmpty());
		Random nums = new Random(); //implementing the random class so that i can generate random numbers
		int[] numbers = new int[100];//declaring my array and setting its size to 100
		int rad = 0;
		int i = 0;
		/*
		 * iterates until the condition is false
		 * during each iteration rad is initialized with a new integer ranging from 0-99
		 * these values are then passed into the object using the insert method created 
		 * in this class
		 */
		while (i < 99) {
			rad = nums.nextInt(99); // rad will be initialized with a value from 0 to 99 each iteration
			numbers[i] = rad;
			i++;
			op.insertFirstNodee(rad, i); // calling the method to insert each number in to the list

		}

		System.out.println("Array unsorted is " + Arrays.toString(numbers)); // displaying the array of integers
		node first = null;
		/*
		 * using a for loop to iterate until it is false. Within this loop
		 * i place each integer in its correct spot within the list by calling my placeNum method
		 */
		for (int l = 0; l < numbers.length; l++) {
			int n = numbers[l];
			op.firstNode = op.placeNum(n, op.firstNode);
			op.sizeD++; // incrementing my field variable

		}
		System.out.println("The sorted tree is ");
		op.orderedBSTree(); // calling the method so that i can display the integers sorted in order

		System.out.println("Size of the tree is " + op.sizeD);
		System.out.println("The tree is empty ?\nThat is " + op.isEmpty());

		System.out.println("How many indexes are there ? " + op.getCountR(op.firstNode));
		
		//System.out.println("Would you like to run this program again?");
		//String prompt = in.next();
		String prompt =" ";
		/*
		 * Here i am taking care of the users response to the prompt above. If the user
		 * enters y or Y then the program will restart by calling the main method. If the user enteres n or N 
		 * then the program will terminate. If the user doesnt enter either of the valid inputs then the prompt will repeat till
		 * a valid character is entered
		 */
		do{
			System.out.println("Would you like to run this program again?");
		 prompt = in.next();
		if(prompt.toLowerCase().equals("y")){
			System.out.println("Program restarting");
			System.out.println("-------------------------------------------------------------------------------------------------");
			main(null);
		}
		else if(prompt.toLowerCase().equals("n")){
			System.out.println("Please wait while the program terminates  ");
			int n =3;
			try {
				 
				Thread.sleep(3000); // will sleep for 3 seconds
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			System.out.println("Program has terminated");
			System.exit(0);
		}
		}while(!(prompt.toLowerCase().equals("y")||prompt.toLowerCase().equals("n")));

	}
	/**
	 * This methods purpose is to display the sorted array.
	 * In this method an object of the node class is created and we use this object
	 * to call the print method located within the node class. The parameter type must be a node
	 * and the method within the node class executes recursively till it reaches a value of null
	 */
	public void orderedBSTree() {
		node n = new node(); // declaring my object of the node class

		n.print(firstNode); // passing in my node to the print method located in the node class
		 
	}// end of orderedBSTree

}//end of BSTree class
